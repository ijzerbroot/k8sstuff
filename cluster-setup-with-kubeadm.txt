
Kubernetes cluster setup using kubeadm

https://kubernetes.io/docs/setup/independent/install-kubeadm/
https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/

Install Ubuntu 16.04 without swap
Set private network-adapter (192.168.1.10 for master)
sudo apt-get install openssh-server git
sudo systemctl enable ssh
sudo systemctl disable ufw
sudo systemctl stop ufw

sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt-get -y update
sudo apt-get -y install docker-ce
sudo apt-get -y install git docker-compose curl

sudo su -


apt-get update && apt-get install -y apt-transport-https
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat <<EOF >/etc/apt/sources.list.d/kubernetes.list
deb http://apt.kubernetes.io/ kubernetes-xenial main
EOF
apt-get update
apt-get install -y kubelet kubeadm kubectl

ON MASTER ONLY:
kubeadm init --apiserver-advertise-address=192.168.1.10 --pod-network-cidr=10.244.0.0/16
sysctl net.bridge.bridge-nf-call-iptables=1

#You can now join any number of machines by running the following on each node
#as root:
#
#  kubeadm join --token 5ed8b1.db01bdd9f6a2a390 192.168.1.10:6443 --discovery-token-ca-cert-hash sha256:0c7561c0c15ccb040eaaa86194e5feaf59ae0c08e81d048954eea832366cf3bd


If you are using VirtualBox (directly or via Vagrant), you will need to ensure that hostname -i returns a routable IP address (i.e. one on the second network interface, not the first one).

install a pod network addon:
export kubever=$(kubectl version | base64 | tr -d '\n')
kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$kubever"

#kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml

following command should show kube-dns pod running:
kubectl get pods --all-namespaces

For allowing pods to be schedukled on master itself:
kubectl taint nodes --all node-role.kubernetes.io/master-

join nodes with the command output by kubeadm

deploy kubernetes dashboard:
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml
OR without SSL:
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/alternative/kubernetes-dashboard.yaml

installeer eventueel heapster et al:
#kubectl create -f https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/influxdb/influxdb.yaml
#kubectl create -f https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/influxdb/grafana.yaml
#kubectl create -f https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/influxdb/heapster.yaml
#kubectl apply --namespace kube-system -f "https://cloud.weave.works/k8s/scope.yaml?k8s-version=$(kubectl version | base64 | tr -d '\n')"
run heapster rbac:
#kubectl apply -f https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/rbac/heapster-rbac.yaml

maar beter TICK stack en ELK



apply the dashboard rbac
proxy the dashboard:
kubectl proxy

make a tunnel and access it as localhost:
http://localhost:8001/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy/


install traefik
kubectl apply -f traefik-role.yaml
kubectl apply -f traefik-daemonset.yaml
kubectl apply -f traefik-web-ui.yaml

monitoring:
kubectl apply -f es-clusterrole.yml
kubectl apply -f es-serviceaccount.yml
kubectl apply -f es-clusterrolebinding.yml
#kubectl apply -f es-statefulset.yml
kubectl apply -f es-pv.yml
kubectl apply -f es-pvclaim.yml
kubectl es-deployment.yml
kubectl apply -f es-service.yml

kubectl apply -f https://raw.githubusercontent.com/elastic/beats/master/deploy/kubernetes/filebeat-kubernetes.yaml
# check status
kubectl --namespace=kube-system get ds/filebeat
